"use strict";
/**
* @author       Eric Kuhn <digit.sensitivee@gmail.com>
* @copyright    2017 Eric Kuhn
* @license      {@link https://opensource.org/licenses/MIT|MIT License}
*/
Object.defineProperty(exports, "__esModule", { value: true });
const Node_1 = require("./Node");
class Grid {
    constructor(_widthOrMatrix, _height, _densityOfObstacles) {
        /* Set the general properties */
        if (typeof _widthOrMatrix === "number") {
            this.m_gridWidth = _widthOrMatrix;
            this.m_gridHeight = _height;
            this.m_totalFields = this.m_gridWidth * this.m_gridHeight;
            this.m_matrix = undefined;
        }
        else {
            this.m_gridWidth = _widthOrMatrix[0].length;
            this.m_gridHeight = _widthOrMatrix.length;
            this.m_totalFields = this.m_gridWidth * this.m_gridHeight;
            this.m_matrix = _widthOrMatrix;
        }
        /* Create and generate the matrix */
        this.m_grid = this.buildGridWithNodes(this.m_matrix, this.m_gridWidth, this.m_gridHeight, _densityOfObstacles);
    }
    /**
     * Builds the grid with the nodes and return it.
     * @param  {number[][]} _matrix [ 0 and 1: 0 = walkable; 1 = not walkable ]
     * @param  {number}     _width Â [ the width of the matrix ]
     * @param  {number}     _height [ the height of the matrix ]
     * @return {Node[][]}           [ the grid with its nodes ]
     */
    buildGridWithNodes(_matrix, _width, _height, _densityOfObstacles) {
        /* Local variables */
        let matrix = [];
        let id = 0;
        /* Generate the matrix */
        for (let y = 0; y < _height; y++) {
            matrix[y] = [];
            for (let x = 0; x < _width; x++) {
                matrix[y][x] = new Node_1.Node({
                    id: id,
                    xPos: x,
                    yPos: y
                });
                id++;
            }
        }
        /**
         * In case we do not have a matrix loaded.
         * Return the matrix now.
         * We do not have to load up more informations.
         */
        if (_matrix === undefined) {
            for (let y = 1; y < _height - 1; y++) {
                for (let x = 1; x < _width - 1; x++) {
                    let randNumber = Math.floor(Math.random() * 10) + 1;
                    if (randNumber > (10 - _densityOfObstacles)) {
                        matrix[y][x].setIsWalkable(false);
                    }
                    else {
                        matrix[y][x].setIsWalkable(true);
                    }
                }
            }
            return matrix;
        }
        /**
         * In case we have a matrix loaded.
         * Load up the informations of the matrix.
         */
        for (let y = 0; y < _height; y++) {
            for (let x = 0; x < _width; x++) {
                if (_matrix[y][x]) {
                    matrix[y][x].setIsWalkable(false);
                }
                else {
                    matrix[y][x].setIsWalkable(true);
                }
            }
        }
        return matrix;
    }
    /**
     * Return a specific node.
     * @param  {number} _x [ the x-position on the grid ]
     * @param  {number} _y [ the y-position on the grid ]
     * @return {Node}      [ the node ]
     */
    getNodeAt(_x, _y) {
        return this.m_grid[_y][_x];
    }
    /**
     * Check if specific node walkable.
     * @param  {number} _x [ the x-position on the grid ]
     * @param  {number} _y [ the y-position on the grid ]
     * @return {boolean}   [ walkable (true) or not walkable (false) ]
     */
    isWalkableAt(_x, _y) {
        return this.m_grid[_y][_x].getIsWalkable();
    }
    /**
     * Check if specific node is on the grid.
     * @param  {number}  _x [ the x-position on the grid ]
     * @param  {number}  _y [ the y-position on the grid ]
     * @return {boolean}    [ on the grid (true) or not on the grid (false) ]
     */
    isOnTheGrid(_x, _y) {
        return (_x >= 0 && _x < this.m_gridWidth) && (_y >= 0 && _y < this.m_gridHeight);
    }
    /**
     * Get surround nodes.
     * @param  {number}  _currentXPos              [ the x-position on the grid ]
     * @param  {number}  _currentYPos              [ the y-position on the grid ]
     * @param  {boolean} _diagnonalMovementAllowed [ is diagnonal movement allowed? ]
     * @return {Node[]}                            [ the surround nodes ]
     */
    getSurroundingNodes(_currentXPos, _currentYPos, _diagnonalMovementAllowed) {
        /* Local variables */
        let surroundingNodes = [];
        for (var y = (_currentYPos - 1); y < (_currentYPos + 2); y++) {
            for (var x = (_currentXPos - 1); x < (_currentXPos + 2); x++) {
                if (this.isOnTheGrid(x, y)) {
                    if (this.isWalkableAt(x, y)) {
                        if (_diagnonalMovementAllowed) {
                            surroundingNodes.push(this.getNodeAt(x, y));
                        }
                        else {
                            if (x == _currentXPos || y == _currentYPos) {
                                surroundingNodes.push(this.getNodeAt(x, y));
                            }
                        }
                    }
                    else {
                        continue;
                    }
                }
                else {
                    continue;
                }
            }
        }
        return surroundingNodes;
    }
    /**
     * Get the Grid
     * @return {Node[][]} [ the generated grid ]
     */
    getGrid() { return this.m_grid; }
    /**
     * Get the grid width
     * @return {number} [ width ]
     */
    getGridWidth() { return this.m_gridWidth; }
    /**
     * Get the grid height
     * @return {number} [ height ]
     */
    getGridHeight() { return this.m_gridHeight; }
    /**
     * Clean the grid
     */
    cleanGrid() {
        for (let y = 0; y < this.m_grid.length; y++) {
            for (let x = 0; x < this.m_grid[y].length; x++) {
                this.m_grid[y][x].setIsOnClosedList(false);
                this.m_grid[y][x].setIsOnOpenList(false);
                this.m_grid[y][x].setParent(undefined);
            }
        }
    }
}
exports.Grid = Grid;
//# sourceMappingURL=Grid.js.map